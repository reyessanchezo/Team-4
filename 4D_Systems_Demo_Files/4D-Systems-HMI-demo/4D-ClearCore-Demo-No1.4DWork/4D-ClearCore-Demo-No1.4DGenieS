#platform "Gen4-uLCD-43DCT-CLB"

//#constant OLDCOMPILE


// generated 1/20/2023 11:33:00 AM
// uSDRequired:- 1   InternalRequired:- 1

#MODE FLASHBANK_1

#inherit "4DGL_16bitColours.fnc"

#inherit "VisualConst.inc"


#inherit "4D-ClearCore-Demo-No1Const.inc"



#constant IPDatasize 22

#CONST
    CMDLenMAX   80
    seroutX     $serout
    serinX      $serin
#END



#CONST
    ColorBGimage     0x0020
    ACK         0x06
    NAK         0x15
    ReadCmd     0x80
    WriteCmd    0x00
//  IPD_TYPE    0 // offsets are doubled as FLASH is byte addressable
    Ofs_IPD_P1      2
    Ofs_IPD_P2      4
    Ofs_IPD_P3      6
    Ofs_IPD_P4      8
    Ofs_IPD_P5      10
    Ofs_IPD_P6      12
    Ofs_IPD_P7      14
    Ofs_IPD_DOWN    16
    Ofs_IPD_RELEASE 18
    Ofs_IPD_OBJVIDX 20
// object indexes
    tDipSwitch      0
    tKnob           1
    tRockerSwitch   2
    tRotarySwitch   3
    tGSlider        4
    tTrackbar       5
    tWinButton      6
    tAngularmeter   7   // need to implement use of this, inputs must be ordered first
    tCoolgauge      8
    tCustomdigits   9
    tForm           10
    tGauge          11
    tImage          12
    tKeyboard       13  // this is a special input, does not need to be at front
    tLed            14
    tLeddigits      15
    tMeter          16
    tStrings        17  // also need output strings code
//    tStringUNI      0x3f | 0x40
//    tStringANSII    0x3f
    tThermometer    18
    tUserled        19
    tVideo          20
    tStaticText     21
// Remove, check for non visual objects instead
//    MaxVisObjects   21  // objects that have a visual component 
    tSounds         22
    tTimer          23
    tSpectrum       24
    tScope          25
    tTank           26
    tUserImages     27
    tPinOutput      28
    tPinInput       29 
    t4Dbutton       30    // more inputs 
    tAniButton      31
    tColorPicker    32 
    tUserButton     33     
    tMagicObject    34     
    tSmartGauge     35 
    tSmartSlider    36 
    tSmartKnob      37 
    tiLedDigitsH       38
    tiAngularMeter     39
    tiGauge            40 
    tiLabelB           41    // Ext
    tiUserGauge        42    // Ext
    tiMediaGauge       43    // Ext
    tiMediaThermometer 44    // Ext
    tiLed              45 
    tiMediaLed         46 
    tiLedDigits        47 
    tiNeedle           48 
    tiRuler            49 
    tiLedDigit         50 
    tiButtonD          51    // Input
    tiButtonE          52    // Input, Ext
    tiMediaButton      53    // Input, Ext
    tiToggleInput      54    // Input, Ext
    tiDial             55    // Input
    tiMediaRotary      56    // Input, Ext
    tiRotaryInput      57    // Input, Ext
    tiSwitch           58    // Input
    tiSwitchB          59    // Input, Ext
    tiSliderE          60    // Input
    tiMediaSlider      61    // Input, Ext
    tiSliderH          62    // Input, Ext
    tiSliderG          63    // Input, Ext
    tiSliderF          64    // Input, Ext
    tiSliderD          65    // Input, Ext
    tiSliderC          66    // Input, Ext
    tiLinearInput      67    // Input, Ext
// tiPanelB, tiScale, tiLabel(ext), have nothing 'settable', nece no object ids
    MaxTotObjects   67 // objects in objects array
    MaxIntObjects   27 // objects in Int objects array, excludes tiLedDigitsH which is the High word of LedDigits
//    OT_DISPLAY      22
    OT_REPORT       100
    OT_SETCONST     101
    OT_SETANOTHER   102
    OT_ACTIVATE     103
    OT_NEXTFRAME    104
    OT_PREVFRAME    105
    OT_NEXTSTRING   106
    OT_PREVSTRING   107
    OT_MAGIC        108
// other OT_s Form activate,
// Indexes into LedDigits and CustomDigits arrays
    Ofs_Digits_Left           0
    Ofs_Digits_Digits         2
    Ofs_Digits_MinDigits      4
    Ofs_Digits_Widthdigit     6
    Ofs_Digits_LeadingBlanks  8
// indexes to Strings arrays
    Ofs_String_StartH        0
    Ofs_String_StartL        2
    Ofs_String_Size          4
    Ofs_String_x1            6
    Ofs_String_y1            8
    Ofs_String_x2            10
    Ofs_String_y2            12
    Ofs_String_FGColor       14
    Ofs_String_BGColor       16
    Ofs_String_FontAttribs   18
    Ofs_String_Transparent   20 // bit transparent should 'refresh' background, otherwise rectangle out
    Ofs_String_Ansi          22 // bit defines write/draw routine
    Ofs_String_Form          24 // form this string can be seen in
    Ofs_String_GciFSFontIdx  26 // only used/exists for GciFS 
// Command codes
    READ_OBJ        0
    WRITE_OBJ       1
    WRITE_STR       2
    WRITE_STRU      3
    WRITE_CONTRAST  4
    REPORT_OBJ      5
    REPORT_EVENT    7
    WRITE_MAGIC_BYTES 8
    WRITE_MAGIC_DBYTES  9
    REPORT_MAGIC_EVENT_BYTES 10
    REPORT_MAGIC_EVENT_DBYTES 11
    WRITE_LABEL     12

// End P1.inc
    nObjects        135
    nInputs         58
    nAniTimers      0
    nKeyboards      1
#END

#CONST
    Ofs_kb_Down
    Ofs_kb_Mvt
    Ofs_kb_State
    Ofs_kb_Ign
    Ofs_kb_Caps
    Ofs_kb_Shift1
    Ofs_kb_Shift2
    Ofs_kb_Ctrl1
    Ofs_kb_Ctrl2
    Ofs_kb_Lock
    Ofs_kb_Buttons
    Ofs_kb_ShiftCaps
#END

#constant KbShiftBit        01
#constant KbCapsBit         02
#constant KbShiftCapsBits   03
#constant KbCtrlBit         04

func refreshstate(var iKB, var oKB)
    var shifted ;
    shifted := oKB[Ofs_kb_State] & KbShiftCapsBits ;
    if (!shifted || (shifted == KbShiftCapsBits))
        shifted := 0 ;
        oKB[Ofs_kb_Caps] := 0 ;
    else
        shifted := 1 ;
        oKB[Ofs_kb_Caps] := 2 ;
    endif
    setkeystate(iKB,shifted) ;
    if (oKB[Ofs_kb_State] & KbCapsBit)
        setkeystate(iKB + oKB[Ofs_kb_Lock],1) ;
    endif
    if ((oKB[Ofs_kb_State] & KbShiftBit) && (shifted))
        setkeystate(iKB + oKB[Ofs_kb_Shift1],1) ;
        setkeystate(iKB + oKB[Ofs_kb_Shift2],1) ;
    endif
    if (oKB[Ofs_kb_State] & KbCtrlBit)
        setkeystate(iKB + oKB[Ofs_kb_Ctrl1],1) ;
        setkeystate(iKB + oKB[Ofs_kb_Ctrl2],1) ;
    endif
endfunc

func kbDown(var iKB, var oKB, var KBKeys, var key)
    var keyval, rtn ;
    oKB[Ofs_kb_Mvt] := 1 ;
    oKB[Ofs_kb_Ign]  := 0 ;
    if ((key == oKB[Ofs_kb_Shift1]) || (key == oKB[Ofs_kb_Shift2]))
        if (oKB[Ofs_kb_State] & KbShiftBit)
            oKB[Ofs_kb_State] &= ~KbShiftBit ;
            oKB[Ofs_kb_Mvt] := 0 ;
        else
            oKB[Ofs_kb_State] |= KbShiftBit ;
        endif
        refreshstate(iKB, oKB) ;
        oKB[Ofs_kb_Ign] := 1 ;
    else if ((key == oKB[Ofs_kb_Ctrl1]) || (key == oKB[Ofs_kb_Ctrl2]))
        if (oKB[Ofs_kb_State] & KbCtrlBit)
            oKB[Ofs_kb_State] &= ~KbCtrlBit ;
            oKB[Ofs_kb_Mvt] := 0 ;
        else
            oKB[Ofs_kb_State] |= KbCtrlBit ;
        endif
        setkeystate(iKB+oKB[Ofs_kb_Ctrl1],oKB[Ofs_kb_Mvt]) ;
        key := oKB[Ofs_kb_Ctrl2] ;
        oKB[Ofs_kb_Ign] := 1 ;
    else if (key == oKB[Ofs_kb_Lock])
        if (oKB[Ofs_kb_State] & KbCapsBit)
            oKB[Ofs_kb_State] &= ~KbCapsBit ;
            oKB[Ofs_kb_Mvt] := 0 ;
        else
            oKB[Ofs_kb_State] |= KbCapsBit ;
        endif
        refreshstate(iKB, oKB) ;
        oKB[Ofs_kb_Ign] := 1 ;
    endif

    if (!oKB[Ofs_kb_Ign])
        if (oKB[Ofs_kb_ShiftCaps])
            keyval := (oKB[Ofs_kb_State] & KbShiftCapsBits) * oKB[Ofs_kb_Buttons] - 1 ;
        else if (((oKB[Ofs_kb_State] & KbShiftCapsBits) == 0) || ((oKB[Ofs_kb_State] & KbShiftCapsBits) == KbShiftCapsBits))
                keyval := - 1 ;
            else
                keyval := oKB[Ofs_kb_Buttons] - 1 ;
        endif
        keyval := KBKeys[key+keyval] ;
        if (oKB[Ofs_kb_State] & KbCtrlBit) keyval &= 0x9F ;
	rtn := rKeyboardRoutines[ActiveKeyboard] ;
        rtn(REPORT_EVENT, tKeyboard, ActiveKeyboard, keyval & 0xff) ;
        setkeystate(iKB+key,oKB[Ofs_kb_Mvt]+oKB[Ofs_kb_Caps]) ;
    endif
    oKB[Ofs_kb_Down] := key ;
endfunc

func setkeystate(var key, var idx)
    img_SetWord(hndl, key,IMAGE_INDEX, idx);
    img_Show(hndl,key) ;
endfunc

func kbUp(var iKB, var oKB)
    if (!oKB[Ofs_kb_Ign])
        setkeystate(iKB + oKB[Ofs_kb_Down],oKB[Ofs_kb_Caps]) ;
        if (oKB[Ofs_kb_State] & KbShiftBit)
            oKB[Ofs_kb_State] &= ~KbShiftBit ;
            refreshstate(iKB, oKB) ;
        endif
        if (oKB[Ofs_kb_State] & KbCtrlBit)
            oKB[Ofs_kb_State] &= ~KbCtrlBit ;
            setkeystate(iKB + oKB[Ofs_kb_Ctrl1],0) ;
            setkeystate(iKB + oKB[Ofs_kb_Ctrl2],0) ;
        endif
        oKB[Ofs_kb_Down] := -1 ;
    endif
endfunc

#DATA
    word gfxInternals -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    word gfxIntParms -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    word gfxIntStrings -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    word xobj2iobj 0
    word IIMediaPanel0 10, 40, 460, 223, BROWN, BLACK, 3, 20, 20, 20, 20, 0x1,
        0x0, 0, 0
    word IIMediaPanel1 10, 114, 460, 75, BROWN, BLACK, 3, 0, 0, 0, 0, 0x1, 0x0,
        0, 0
    word IIMediaPanel2 0, 104, 311, 168, BROWN, BLACK, 3, 0, 15, 0, 0, 0x1,
        0x0, 0, 0
    word IIMediaPanel3 0, 104, 311, 168, BROWN, BLACK, 3, 0, 15, 0, 0, 0x1,
        0x0, 0, 0
    word IIMediaPanel4 0, 104, 311, 168, BROWN, BLACK, 3, 0, 15, 0, 0, 0x1,
        0x0, 0, 0
    word FormStartIndex 0, 4, 20, 54, 86, 118
    word FormEndIndex 4, 20, 54, 86, 118, 135
    word iFormStartIndex 0, 0, 0, 0, 0, 0
    word iFormEndIndex 0, 0, 0, 0, 0, 0
    word iiFormStartIndex 0, 0, 0, 0, 0, 0
    word iiFormEndIndex 0, 0, 0, 0, 0, 0
    word InputControls -1, -1, -1, -1, -1, 0, 44, 88, 132, 176, -1, -1, 220, 264, 308, 352, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 396, -1, -1, -1, -1, 440, 484, 528, 572, -1, -1, -1, 616, -1, -1, -1, -1, 660, -1, -1, -1, -1, -1, -1, -1,
                    -1, -1, -1, -1, -1, -1, -1, -1, -1, 704, 748, 792, 836, 880, -1, -1, -1, -1, -1, -1, -1, -1, 924, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 968, 1012, 1056, 1100, 1144, -1, -1, -1, -1, -1, -1, -1, -1, 1188, -1, -1, -1, 1232, -1,
                    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1232
    word InternalInputControls 0
    word InputData tWinButton, 1, -1, -1, -1, -1, -1, -1, 0, 22, 2,
                OT_REPORT, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                tWinButton, 1, -1, -1, -1, -1, -1, -1, 0, 66, 4,
                OT_REPORT, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                tWinButton, 1, -1, -1, -1, -1, -1, -1, 0, 110, 6,
                OT_REPORT, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2,
                t4Dbutton, 1, -1, -1, -1, -1, -1, -1, 0, 154, 2,
                OT_REPORT, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                t4Dbutton, 1, -1, -1, -1, -1, -1, -1, 0, 198, 4,
                OT_REPORT, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
                t4Dbutton, 1, -1, -1, -1, -1, -1, -1, 0, 242, 6,
                OT_REPORT, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2,
                t4Dbutton, 1, -1, -1, -1, -1, -1, -1, 0, 286, 8,
                OT_REPORT, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3,
                t4Dbutton, 1, -1, -1, -1, -1, -1, -1, 0, 330, 10,
                OT_REPORT, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4,
                t4Dbutton, 1, -1, -1, -1, -1, -1, -1, 0, 374, 12,
                OT_REPORT, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5,
                tWinButton, 1, -1, -1, -1, -1, -1, -1, 0, 418, 8,
                OT_REPORT, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3,
                tWinButton, 1, -1, -1, -1, -1, -1, -1, 0, 462, 10,
                OT_REPORT, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4,
                tWinButton, 1, -1, -1, -1, -1, -1, -1, 0, 506, 12,
                OT_REPORT, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5,
                tWinButton, 1, -1, -1, -1, -1, -1, -1, 0, 550, 14,
                OT_REPORT, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6,
                tWinButton, 1, -1, -1, -1, -1, -1, -1, 0, 594, 16,
                OT_REPORT, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7,
                t4Dbutton, 1, -1, -1, -1, -1, -1, -1, 0, 638, 14,
                OT_REPORT, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6,
                t4Dbutton, 0, -1, -1, -1, -1, -1, -1, 0, 682, 16,
                OT_REPORT, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7,
                tWinButton, 1, -1, -1, -1, -1, -1, -1, 0, 726, 18,
                OT_REPORT, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8,
                tWinButton, 1, -1, -1, -1, -1, -1, -1, 0, 770, 20,
                OT_REPORT, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9,
                tWinButton, 1, -1, -1, -1, -1, -1, -1, 0, 814, 22,
                OT_REPORT, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10,
                tWinButton, 1, -1, -1, -1, -1, -1, -1, 0, 858, 24,
                OT_REPORT, 0, 0, 0, 0, 0, 0, 0, 0, 0, 11,
                tWinButton, 1, -1, -1, -1, -1, -1, -1, 0, 902, 26,
                OT_REPORT, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12,
                t4Dbutton, 1, -1, -1, -1, -1, -1, -1, 0, 946, 18,
                OT_REPORT, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8,
                tWinButton, 1, -1, -1, -1, -1, -1, -1, 0, 990, 28,
                OT_REPORT, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13,
                tWinButton, 1, -1, -1, -1, -1, -1, -1, 0, 1034, 30,
                OT_REPORT, 0, 0, 0, 0, 0, 0, 0, 0, 0, 14,
                tWinButton, 1, -1, -1, -1, -1, -1, -1, 0, 1078, 32,
                OT_REPORT, 0, 0, 0, 0, 0, 0, 0, 0, 0, 15,
                tWinButton, 1, -1, -1, -1, -1, -1, -1, 0, 1122, 34,
                OT_REPORT, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16,
                tWinButton, 1, -1, -1, -1, -1, -1, -1, 0, 1166, 36,
                OT_REPORT, 0, 0, 0, 0, 0, 0, 0, 0, 0, 17,
                t4Dbutton, 1, -1, -1, -1, -1, -1, -1, 0, 1210, 20,
                OT_REPORT, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9,
                tWinButton, 1, -1, -1, -1, -1, -1, -1, 0, 1254, 38,
                OT_REPORT, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18
    word oDipSwitchs 0
    word oWinButtons 19, iWinbutton0, iWinbutton1, iWinbutton2, iWinbutton3, iWinbutton4, iWinbutton5, iWinbutton6, iWinbutton7, iWinbutton8, iWinbutton9, iWinbutton10, iWinbutton11, iWinbutton12, iWinbutton13, iWinbutton14, iWinbutton15, iWinbutton16, iWinbutton17, iWinbutton18
    word oForms 6, -1, -1, -1, -1, -1, -1
    word oKeyboards 1, iKeyboard0
    word oLeddigitss 19, iLeddigits0, iLeddigits1, iLeddigits2, iLeddigits3, iLeddigits4, iLeddigits5, iLeddigits6, iLeddigits7, iLeddigits8, iLeddigits9, iLeddigits10, iLeddigits11, iLeddigits12, iLeddigits13, iLeddigits14, iLeddigits15, iLeddigits16, iLeddigits17, iLeddigits18
    word oUserleds 3, iUserled0, iUserled1, iUserled2
    word oVideos 10, iVideo0, iVideo1, iVideo2, iVideo3, iVideo4, iVideo5, iVideo6, iVideo7, iVideo8, iVideo9
    word oStaticTexts 42, iStatictext0, iStatictext1, iStatictext2, iStatictext3, iStatictext4, iStatictext5, iStatictext6, iStatictext7, iStatictext8, iStatictext9, iStatictext10, iStatictext11, iStatictext12, iStatictext13, iStatictext14, iStatictext15, iStatictext16,
                    iStatictext17, iStatictext18, iStatictext19, iStatictext20, iStatictext21, iStatictext22, iStatictext23, iStatictext24, iStatictext25, iStatictext26, iStatictext27, iStatictext28, iStatictext29, iStatictext30, iStatictext31, iStatictext32, iStatictext33,
                    iStatictext34, iStatictext35, iStatictext36, iStatictext37, iStatictext38, iStatictext39, iStatictext40, iStatictext41
    word o4Dbuttons 10, i4Dbutton0, i4Dbutton1, i4Dbutton2, i4Dbutton3, i4Dbutton4, i4Dbutton5, i4Dbutton6, i4Dbutton7, i4Dbutton8, i4Dbutton9
    word FormBGcolors 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000
    word kKeyboardKeystrokes iKeyboard0keystrokes
    word rKeyboardRoutines SendReport
    word oLedDigitsn 9, 5, 1, 29, 0,
                111, 5, 1, 29, 0,
                140, 4, 1, 29, 0,
                140, 4, 1, 29, 0,
                140, 4, 1, 29, 0,
                219, 3, 1, 30, 0,
                9, 5, 1, 29, 0,
                111, 5, 1, 29, 0,
                140, 4, 1, 29, 0,
                140, 4, 1, 29, 0,
                140, 4, 1, 29, 0,
                388, 3, 1, 30, 0,
                9, 5, 1, 29, 0,
                111, 5, 1, 29, 0,
                140, 4, 1, 29, 0,
                140, 4, 1, 29, 0,
                140, 4, 1, 29, 0,
                388, 3, 1, 30, 0,
                333, 5, 1, 29, 0
#END






    var gradientRAM[29+461*2] := [-1,-1,-9999,0,0,461] ;  // with init and showing capacity for 460 degrees
var dKeyboard[1], ActiveKeyboard ;
// Start P2.inc
var vObjects[MaxIntObjects+1] ;              // address of RAM objects
var GObjectIdx, GObjectFunc, GObjectRAM, GObjectDATA, GObjectParms, GObjectStrings ;
var oObjects[MaxTotObjects+1] ;                 // address of objects
var CurrentForm, oldn, ImageTouched ;
var TouchXpos, TouchYpos ;
var GObjectType, TouchState, CurInputData, pInputIndex ;
var comRX[40], cmd[CMDLenMAX] ;

var InputCS, OutputCS ;

// > ? Constant/Global/Data ? <


func addressInternalWidget(var idx var iponly)
    var i, j ;
//to(COM0) ; print("Address Int ", idx, " ") ;
    GObjectIdx := xobj2iobj[idx] ;
    GObjectType := (GObjectIdx>>8) ;                          // extract object type
    i := oObjects[GObjectType] ;                              // i is address of list of all objects of this type
    GObjectIdx &= 0xff ;
    //GObjectIdx *= 2 ;
    j := GObjectIdx * 2 ;
    GObjectDATA := i[j + 2] ;                                 // address of this object
    i := vObjects[GObjectType-tiAngularMeter] ;               // i is address of list of all ram objects of his type
    GObjectRAM := i[j] ;                                      // address of this objects' ram
    i := GObjectType-tiAngularMeter ;
    GObjectFunc := gfxInternals[i] ; // address function
    GObjectParms := gfxIntParms[i] ;
    GObjectStrings := gfxIntStrings[i] ;
//to(COM0) ; print([HEX4] GObjectFunc, " ", [HEX4] GObjectRAM, " ", [HEX4] GObjectDATA, " ", GObjectType, " ", GObjectIdx, "\r\n") ;
//    GObjectFunc(0, GObjectRAM, GObjectDATA) ;
endfunc

func seroutCS(var op)
    serout(op) ;
    OutputCS ^= op ;
endfunc

func nak0()
    serout(NAK) ;
    InputCS := 0 ;
endfunc

func seroutOcs()
    serout(OutputCS) ;
    OutputCS := 0 ;
endfunc

func SendReport(var id, var objt, var objn, var val)
    seroutCS(id) ;
    seroutCS(objt) ;
    seroutCS(objn) ;
    seroutCS(val >> 8) ; // first 8 bits
    seroutCS(val) ;
    seroutOcs() ;
endfunc



func ReadObject(var ObjectType, var ObjectIdx)
    var j, k, Objects ;
    if ((ObjectType >= tiLedDigitsH) && (ObjectType <= tiLinearInput))
        j := ObjectIdx *2 ;
        k := vObjects[ObjectType-tiAngularMeter] ;               // k is address of list of all ram objects of his type
        k := k[j] ;                                              // k is address of this objects' ram
        if (ObjectType == tiLedDigit)
            k := k[0] ;
        else 
            k := k[WIDGET_VAL1] ;
        endif
//gfx_MoveTo(0,0); txt_Opacity(OPAQUE) ; print(ObjectType, " ", ObjectIdx, " ", k," ") ;
    else
    Objects := *(oObjects+ObjectType) ;

    j := 2 + ObjectIdx * 2 + Objects ;
     if (ObjectType == tForm)
        k := CurrentForm ;
    else if ((ObjectType == tCustomdigits) || (ObjectType == tLeddigits))
        k := img_GetWord(hndl, *j, IMAGE_TAG2);
        else
        k := img_GetWord(hndl, *j, IMAGE_INDEX);
        if (((ObjectType == tWinButton) || (ObjectType == tAniButton) || (ObjectType == tUserButton) || (ObjectType == t4Dbutton)) && (k)) k := 1 ; // this is not correct for blocked buttons and cannot be fixed as we cannot
                                                                                                                                                    // determine if button is momentary or not which is needed for correct answer.
    endif
    endif
    SendReport(REPORT_OBJ, ObjectType, ObjectIdx, k) ;
endfunc

var wp ;


func WriteObject(var ObjectType, var ObjectIdx, var NewVal)
    var i, j, k, Objects ;
//    ObjectType &= 0x3f ; Why was his there? Anibuttons? Complex cascades?
//to(COM0) ; print("WriteObject ", ObjectType, " ", ObjectIdx, " ", NewVal, "\r\n") ;
    if (ObjectType == tForm)
        ActivateForm(ObjectIdx) ;
        return ;
    endif
        Objects := *(oObjects+ObjectType)+ObjectIdx*2+2 ;
        i := *(Objects) ;
	if ((ObjectType >= tiAngularMeter) && (ObjectType <= tiLinearInput))
            i := oObjects[ObjectType] ;                              // f is address of list of all objects of this type
            j := ObjectIdx *2 ;
            i := i[j + 2] ;                         // f is address of this object
            k := vObjects[ObjectType-tiAngularMeter] ;               // a is address of list of all ram objects of his type
            k := k[j] ;                             // a is address of this objects' ram
                j := ObjectType-tiAngularMeter ;
                Objects := gfxInternals[j] ;           // locate function address   
            if (gfxIntParms[j] == -1)             // (Objects < 0)
                Objects(NewVal, k, i) ; 
            else
                flash_FunctionCall(FLASHBANK_5, Objects, NewVal, k, i, gfxIntParms[j], gfxIntStrings[j]) ; 
            endif
        return ;
    endif
        switch (ObjectType)
            case tWinButton :
                j := InputControls[oWinButtons[ObjectIdx+1]] ;
                break ;
            case t4Dbutton :
                j := InputControls[o4Dbuttons[ObjectIdx+1]] ;
                break ;
            default : j := -1 ;
        endswitch
        if (j != -1)
            k := img_GetWord(hndl, i , IMAGE_INDEX) ;
            NewVal := NewVal << 1 ;
            if (OVF())      // button group index change
                if (*(j+InputData+Ofs_IPD_P1))
                    k &= 1 ;    // mask off old group index for momentary
                else
                    k &= 3 ;    // mask off old group index for toggle
                endif
            else            // normal set
                if (*(j+InputData+Ofs_IPD_P2) != -1) TurnOffButtons(*(j+InputData+Ofs_IPD_P2)) ;
                k &= 0xfffc ;    // retain only group index for state set
            endif
            NewVal |= k ;
//        endif
        endif
        if (ObjectType == tLeddigits)
            img_SetWord(hndl, i , IMAGE_TAG2, NewVal); // where state is 0 to 2
            ledDigitsDisplay(i, oLeddigitss, oLedDigitsn) ;
            return ;
        endif 
            img_SetWord(hndl, i , IMAGE_INDEX, NewVal); // where state is 0 to 2
            img_Show(hndl, i) ; // will only display if form is current
    return ; // compiler bug circumvention!
endfunc

func TurnOffButtons(var group)
    var j, k, l, m, n, o, p;
    m := GObjectIdx ;     // save as will be clobbered
    n := GObjectType ;     // save as will be clobbered
    for (j := 0; j < nInputs; j++)
        k := j*IPDatasize ;
        if (*(InputData+k+Ofs_IPD_P2) == group)
            l := -1 ;
             if (*(InputData+k) == t4Dbutton)
                l := o4Dbuttons[*(InputData+k+Ofs_IPD_OBJVIDX)/2] ;
                img_SetWord(hndl, l, IMAGE_INDEX, 0);
                img_Show(hndl, l);      // only shows on current form
            else if (*(InputData+k) == tWinButton)
                l := oWinButtons[*(InputData+k+Ofs_IPD_OBJVIDX)/2] ;
                img_SetWord(hndl, l, IMAGE_INDEX, 0);
                img_Show(hndl, l);      // only shows on current form

            endif
        endif
    next
    GObjectIdx := m ;     // Restore
    GObjectType := n ;    // Restore
endfunc


// WARNING, this code will crash if newval exceeds maximum displayable number
func ledDigitsDisplay(var imgidx, var typeptr, var setptr)
    var i, j, k, l, lb, newval, num[4] ;
    if (!((img_GetWord(hndl, imgidx, IMAGE_FLAGS) & I_ENABLED))) return ;  // ;img_GetWord(hndl, imgidx, IMAGE_TAG2) ;if diabled then exit
    newval := img_GetWord(hndl, imgidx, IMAGE_TAG2) ;
    i := -1 ;
    j := *(typeptr) ;
    repeat
        typeptr += 2 ;
        i++ ;
        until (*(typeptr) == imgidx);
    j := setptr + i*10 ;

    l := 0x500a | (*(j+Ofs_Digits_Digits) << 8) ;       // UDECxZ
    to(num) ;
    putnum(l, newval) ;
    imgidx++ ;
    lb := *(j+Ofs_Digits_LeadingBlanks) ;
    l := str_Ptr(num) ;
    for (i := 0; i < *(j+Ofs_Digits_Digits); i++)
        k := str_GetByte(l++) & 0x0f ;
        if ( lb && (i < *(j+Ofs_Digits_Digits) - *(j+Ofs_Digits_MinDigits)) )
            if (k == 0)
                k := 10 ;
            else
                lb := 0 ;
            endif
        endif
        img_SetWord(hndl, imgidx, IMAGE_INDEX, k);
        img_SetWord(hndl, imgidx, IMAGE_XPOS, *(j+Ofs_Digits_Left)+i* *(j+Ofs_Digits_Widthdigit)) ;
        img_Show(hndl, imgidx);
    next
endfunc


func ActivateForm(var newform)
    var i, j, *p ;

        widget_Disable(wp, ALL) ;
    if (CurrentForm != -1) // deactivate old form, by disabling all inputs
        for (i := FormStartIndex[CurrentForm]; i <= FormEndIndex[CurrentForm]; i++)
            if (img_GetWord(hndl, i, IMAGE_TAG))
                img_Disable(hndl,i) ;
            endif
        next
    endif
    CurrentForm := newform ;
    // display newform image or clear to image color
    if (FormBGcolors[CurrentForm] != ColorBGimage)
        gfx_Set(BACKGROUND_COLOUR,FormBGcolors[CurrentForm]);
        gfx_Cls() ;
        DoGFXObjects() ;                                    // display GFX 'widgets'
    endif

    // enable inputs
    for (i := FormStartIndex[CurrentForm]; i < FormEndIndex[CurrentForm]; i++)
        j := img_GetWord(hndl, i, IMAGE_TAG) ;
        if (j)
            j-- ;
            img_SetAttributes(hndl, i, I_STAYONTOP+I_ENABLED);        // make sure this is on top of form, if applicable
            //if (j != tKeyboard)
            if ((j <= tWinButton) || (j >= t4Dbutton) )               // enable inputs
                img_ClearAttributes(hndl, i, I_TOUCH_DISABLE);        // ensure touch is enabled
            endif
            img_Show(hndl,i) ; // show initialy, if required
            if (j == tForm)
                DoGFXObjects() ;                                    // display GFX 'widgets' for image backgruobds
            else if (j == tLeddigits)
                ledDigitsDisplay(i, oLeddigitss, oLedDigitsn) ;
            endif
        endif
    next

    // enable inputs
       var a, f ; 
/*print("oiviAngularMeter ", [HEX4] oiviAngularMeter, " ", oiviAngularMeter[0], " ", [HEX4]vIAngularMeter0, "\n") ;
print("oiviGauge ", [HEX4] oiviGauge, " ", [HEX4] oiviGauge[0], " ", [HEX4] vIGauge0, "\n") ;
print("oiviButtonD ", [HEX4] oiviButtonD, " ", [HEX4] oiviButtonD[0], " ", [HEX4] vIButtonD0, "\n") ;
print("vIAngularMeter0 ", [HEX4] vIAngularMeter0, "\n") ;
print("vIButtonD0 ", [HEX4] vIButtonD0, "\n") ;
print("vIGauge0 ", [HEX4] vIGauge0, "\n") ;
print("IIAngularMeter0 ", [HEX4] IIAngularMeter0, "\n") ;
print("IIButtonD0 ", [HEX4] IIButtonD0, "\n") ;
print("IIGauge0 ", [HEX4] IIGauge0, "\n") ;
print([HEX4] gfxInternals, " ", [HEX4] gfx_AngularMeter, " ", [HEX4] gfx_Gauge, " ", [HEX4] gfx_Button4, "\n") ;
*/
    for (i := iFormStartIndex[CurrentForm]; i < iFormEndIndex[CurrentForm]; i++)
        addressInternalWidget(i, 0) ;
        widget_Enable(wp,i) ;
        if (GObjectType != tiLabelB) widget_ClearAttributes(wp,i,WIDGET_F_INITIALISED) ; // don't clear initialised for tiLabelB
                j := GObjectRAM[WIDGET_VAL1] ;
            if (GObjectParms == -1)                                 // GObjectFunc < 0)
                GObjectFunc(j, GObjectRAM, GObjectDATA) ; 
            else
                flash_FunctionCall(FLASHBANK_5, GObjectFunc, j, GObjectRAM, GObjectDATA, GObjectParms, GObjectStrings) ; 
            endif
    next
    for (i := iFormStartIndex[CurrentForm]; i < iFormEndIndex[CurrentForm]; i++)
        if (InternalInputControls[i] != -1)
            widget_SetAttributes(wp,i,WIDGET_F_TOUCH_ENABLE) ;
        endif
    next


endfunc

func UpdateObjects(var newval)
    var IPidx, otherOBJ, oldvalue ;
    if (GObjectType < tiLedDigitsH)
        oldvalue := img_GetWord(hndl, *(pInputIndex), IMAGE_INDEX) ;
    else
        oldvalue := GObjectRAM[WIDGET_VAL1] ;
    endif
    if ( ( oldvalue != newval) || (TouchState == Ofs_IPD_RELEASE) ) // only bother if values changed, or release
    if (GObjectType < tiLedDigitsH)
        img_SetWord(hndl, *(pInputIndex), IMAGE_INDEX, newval);
            img_Show(hndl, *(pInputIndex));      // only shows on current form
    else
        WriteObject(GObjectType, GObjectIdx, newval) ;
    endif
        if ((GObjectType == t4Dbutton) || (GObjectType == tUserButton) || (GObjectType == tWinButton))
            if (*(CurInputData+Ofs_IPD_P1))
                newval &= 1;
            else
                newval &= 3;
            endif
            if (newval > 1) newval := 1;
        endif
        IPidx := *(CurInputData+TouchState) ;
        while(IPidx != 0)
            otherOBJ := IPidx + InputData;
            if (*(otherOBJ) == OT_REPORT)
        SendReport(REPORT_EVENT, GObjectType, *(otherOBJ+Ofs_IPD_OBJVIDX), newval) ;
            else if (*(otherOBJ) == OT_MAGIC)
                IPidx := *(otherOBJ+Ofs_IPD_P5) ;
                IPidx(newval) ;
//            else if (TouchState == *(otherOBJ+Ofs_IPD_P4))  // test prior to Workshop 6.5.0.0
            else if ((TouchState == *(otherOBJ+Ofs_IPD_P4)) || (*(CurInputData+Ofs_IPD_P1) && ((GObjectType == t4Dbutton) || (GObjectType == tUserButton) || (GObjectType == tWinButton))))
                if (*(otherOBJ) == OT_ACTIVATE)
                    ActivateForm(*(otherOBJ+Ofs_IPD_P2) ) ;
                    GObjectType := tForm ;
                else if (*(otherOBJ) == OT_SETCONST)
                    newval := *(otherOBJ+Ofs_IPD_P3) ;
                    WriteObject(*(otherOBJ+Ofs_IPD_P1), *(otherOBJ+Ofs_IPD_P2), newval) ;
                else if (*(otherOBJ) == OT_SETANOTHER)
                    WriteObject(*(otherOBJ+Ofs_IPD_P1), *(otherOBJ+Ofs_IPD_P2), newval) ;
                else if (*(otherOBJ) == OT_PREVFRAME)
                    if (img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX))
                        WriteObject(*(otherOBJ+Ofs_IPD_P5),*(otherOBJ+Ofs_IPD_P2),img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX)-1) ;
                    endif
                    newval := img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX) ;
                else if (*(otherOBJ) == OT_NEXTFRAME)
                    if (img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX) < *(otherOBJ+Ofs_IPD_P3))
                        WriteObject(*(otherOBJ+Ofs_IPD_P5),*(otherOBJ+Ofs_IPD_P2),img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX)+1) ;
                    endif
                    newval := img_GetWord(hndl, *(otherOBJ+Ofs_IPD_P6), IMAGE_INDEX) ;
                endif
            endif
            IPidx := *(otherOBJ+TouchState) ;
        wend
    endif
endfunc

// End P2.inc
func DoGFXObjects()
    var vPanelx[WIDGET_RAM_SPACE] ;
    vPanelx[WIDGET_TAG] := gradientRAM ;
    switch (CurrentForm)
        case 1:
            flash_FunctionCall(FLASHBANK_5, Fgfx_MediaPanel, 0, vPanelx, IIMediaPanel0, 16, 0) ;
            flash_FunctionCall(FLASHBANK_5, Fgfx_MediaPanel, 0, vPanelx, IIMediaPanel1, 16, 0) ;
        break ;
        case 2:
            flash_FunctionCall(FLASHBANK_5, Fgfx_MediaPanel, 0, vPanelx, IIMediaPanel2, 16, 0) ;
        break ;
        case 3:
            flash_FunctionCall(FLASHBANK_5, Fgfx_MediaPanel, 0, vPanelx, IIMediaPanel3, 16, 0) ;
        break ;
        case 4:
            flash_FunctionCall(FLASHBANK_5, Fgfx_MediaPanel, 0, vPanelx, IIMediaPanel4, 16, 0) ;
        break ;
    endswitch
endfunc

// Start P3.inc
func main()
    var comTX[50], cmdi, i, j, TouchStatus ;

    ActiveKeyboard := -1 ;

    gfx_ScreenMode(LANDSCAPE) ;

    if (flash_GetWord(FLASHBANK_5, 0x17) != 'IB')
        print("Error 30") ;
        repeat forever
    endif
    putstr("Mounting...\n");
    if (!(file_Mount()))
        while(!(file_Mount()))
            putstr("Drive not mounted...");
            pause(200);
            gfx_Cls();
            pause(200);
        wend
    endif

//    gfx_MoveTo(0, 0);
//    print(mem_Heap()," ") ;
//    gfx_TransparentColour(0x0020);
//    gfx_Transparency(ON);


    // open image control
    hndl := file_LoadImageControl("4D-CLE~1.dat", "4D-CLE~1.gci", 1);


    // init 'constants'
// End P3.inc

    oObjects[tDipSwitch] := oDipSwitchs ; // dummy as no object there
    oObjects[tKnob] := oDipSwitchs ; // dummy as no object there
    oObjects[tRockerSwitch] := oDipSwitchs ; // dummy as no object there
    oObjects[tRotarySwitch] := oDipSwitchs ; // dummy as no object there
    oObjects[tGSlider] := oDipSwitchs ; // dummy as no object there
    oObjects[tTrackbar] := oDipSwitchs ; // dummy as no object there
    oObjects[tWinButton] := oWinButtons ;
    oObjects[tAngularmeter] := oDipSwitchs ; // dummy as no object there
    oObjects[tCoolgauge] := oDipSwitchs ; // dummy as no object there
    oObjects[tCustomdigits] := oDipSwitchs ; // dummy as no object there
    oObjects[tForm] := oForms ;
    oObjects[tGauge] := oDipSwitchs ; // dummy as no object there
    oObjects[tImage] := oDipSwitchs ; // dummy as no object there
    oObjects[tKeyboard] := oKeyboards ;
    oObjects[tLed] := oDipSwitchs ; // dummy as no object there
    oObjects[tLeddigits] := oLeddigitss ;
    oObjects[tMeter] := oDipSwitchs ; // dummy as no object there
    oObjects[tStrings] := oDipSwitchs ; // dummy as no object there
    oObjects[tThermometer] := oDipSwitchs ; // dummy as no object there
    oObjects[tUserled] := oUserleds ;
    oObjects[tVideo] := oVideos ;
    oObjects[tStaticText] := oStaticTexts ;
    oObjects[tSounds] := oDipSwitchs ; // dummy as no object there
    oObjects[tTimer] := oDipSwitchs ; // dummy as no object there
    oObjects[tSpectrum] := oDipSwitchs ; // dummy as no object there
    oObjects[tTank] := oDipSwitchs ; // dummy as no object there
    oObjects[tUserImages] := oDipSwitchs ; // dummy as no object there
    oObjects[tPinOutput] := oDipSwitchs ; // dummy as no object there
    oObjects[tPinInput] := oDipSwitchs ; // dummy as no object there
    oObjects[t4Dbutton] := o4Dbuttons ;
    oObjects[tAniButton] := oDipSwitchs ; // dummy as no object there
    oObjects[tColorPicker] := oDipSwitchs ; // dummy as no object there
    oObjects[tUserButton] := oDipSwitchs ; // dummy as no object there
    dKeyboard[0] := oKeyboard0 ;
// Start P4.inc

    // init comms
    com_Init(comRX,CMDLenMAX,0);
    com_SetBaud(COM0,11520);
    com_TXbuffer(comTX, 100, 0);
    // tag 'real' objects
    for (i := 0; i <= MaxTotObjects; i++)
        if (   (i != tSounds)
            && (i != tTimer)
            && (i != tPinOutput)
            && (i != tPinInput) )
            TouchXpos := oObjects[i] ;
            TouchYpos := *(TouchXpos) ;
            for (ImageTouched := 1; ImageTouched <= TouchYpos; ImageTouched++)
                oldn := *(TouchXpos+ImageTouched*2) ;
                img_SetAttributes(hndl, oldn, I_TOUCH_DISABLE);  // ensure touch is enabled
                if (oldn != -1)
                    img_SetWord(hndl, oldn, IMAGE_TAG, i+1);
                    img_Disable(hndl, oldn) ;
                endif
            next
        endif
    next


    for (i := 0; i < nKeyboards; i++) // for each kb key, set tag to -1
        if (oKeyboards[i+1] != -1)               // if keyboard exists
            for(ImageTouched := oKeyboards[i+1]+1; ImageTouched <= oKeyboards[i+1]+*(dKeyboard[i] + Ofs_kb_Buttons); ImageTouched++)
                img_SetWord(hndl, ImageTouched, IMAGE_TAG, -1);
            next
        endif
    next
    // display initial form
    CurrentForm := -1 ;
// End P4.inc
// Start P5.inc
    ActivateForm(0) ; // need to change this according to first actual form

// End P5.inc
// Start P6.inc Diablo
    touch_Set(TOUCH_ENABLE);                            // enable the touch screen
    oldn := -1 ;
    repeat

        // check comms for command, how to NAK invalid command
        if (com_Count() != 0)
            i := serin() ;
            InputCS ^= i ;               // update checksum
                cmd[cmdi++] := i ;
                 if (   (cmd[0] == READ_OBJ)
                         && (cmdi == 4)         )
                    if (InputCS)
                        nak0() ;
                    else
                        ReadObject(cmd[1], cmd[2]) ;
                    endif
                    cmdi := 0 ;
                else if (   (cmd[0] == WRITE_OBJ)    // 6 byte write command (gen option)
                         && (cmdi == 6)          )
                    if (InputCS)
                        nak0() ;
                    else
                        WriteObject(cmd[1], cmd[2], cmd[3] << 8 + cmd[4]) ;
                        serout(ACK) ;
                    endif
                    cmdi := 0 ;
                else if (   (cmd[0] == WRITE_CONTRAST)
                         && (cmdi == 3)         )
                    if (InputCS)
                        nak0() ;
                    else
                        gfx_Contrast(cmd[1]) ;
                        serout(ACK) ;
                    endif
                    cmdi := 0 ;
                else if (cmdi == 6)    // we have 6 bytes and we've gotten here -> something wrong
                    nak0() ;
                    cmdi := 0 ;
                endif
        endif   // a character is available


    // touch code processing

        TouchStatus := touch_Get(TOUCH_STATUS);               // get touchscreen status
        if ((TouchStatus == TOUCH_PRESSED) || (TouchStatus == TOUCH_RELEASED) || (TouchStatus == TOUCH_MOVING))
            ImageTouched := img_Touched(hndl,-1) ;
            if (ImageTouched == -1)
                ImageTouched := widget_Touched(wp, ALL) ;
                if (ImageTouched != -1) ImageTouched := -2 - ImageTouched ;
            endif
            if ((TouchStatus != TOUCH_RELEASED) && (ImageTouched != oldn) && (oldn != -1))
                TouchStatus := TOUCH_RELEASED ;       // simulate release if we move off object
            endif
            if (TouchStatus != TOUCH_RELEASED)        // if not released
                if (oldn != -1)
                    ImageTouched := oldn ;
                else
                    if (oldn != ImageTouched)
                oldn := ImageTouched ;
                        TouchStatus := TOUCH_PRESSED ;
                    endif
                endif
                TouchXpos  := touch_Get(TOUCH_GETX);
                TouchYpos  := touch_Get(TOUCH_GETY);
                TouchState := Ofs_IPD_DOWN ;
            else
                ImageTouched := oldn ;                     // simulate release of what we touched
                oldn := -1 ;                    // prevent double release
                TouchState := Ofs_IPD_RELEASE ;
            endif
            if (ImageTouched >= 0)
                // if touch released then find a keyboard down, if one then release it
                if ((TouchStatus == TOUCH_RELEASED) && (ActiveKeyboard != -1))
                    kbUp(oKeyboards[ActiveKeyboard+1], dKeyboard[ActiveKeyboard]) ;
                    ActiveKeyboard := -1 ;
                else
                    i := 0 ;
                    while ((i < nKeyboards) && ((-1 == oKeyboards[i+1]) || (ImageTouched <= oKeyboards[i+1]) || (ImageTouched > oKeyboards[i+1] + *(dKeyboard[i]+Ofs_kb_Buttons))))
                        i++ ;
                    wend
                    if (i < nKeyboards)
                        if (TouchStatus == TOUCH_PRESSED)
                            ActiveKeyboard := i ;
                            kbDown(oKeyboards[ActiveKeyboard+1], dKeyboard[ActiveKeyboard], kKeyboardKeystrokes[ActiveKeyboard], ImageTouched-oKeyboards[ActiveKeyboard+1]) ;
                        endif
                    else
                        CurInputData := InputControls[ImageTouched] + InputData;
                        GObjectType := *(CurInputData) ;
                        i := GObjectType ;
                        if (GObjectType >= t4Dbutton) i -= 23 ; // adjust to ensure next in gosub
                        gosub (i), (cDipswitch, cKnob, cRockerswitch, cRotaryswitch, cSlider, cTrackbar, cWinbutton, c4DButton, cAniButton, cColorPicker, cUserButton) ;
                        ImageTouched := -1 ; // show processed here
                    endif
                endif
            endif
            if (ImageTouched != -1) ImageTouched := -2 - ImageTouched ;
            if (ImageTouched >= 0)
//print(ImageTouched," ") ;
//                        CurInputData := InternalInputControls[ImageTouched] + InternalInputData;
                        CurInputData := InternalInputControls[ImageTouched] + InputData;
//                        GObjectType := *(CurInputData) ;
//                        i := GObjectType ;
//                        if (GObjectType >= t4Dbutton) i -= 23 ; // adjust to ensure next in gosub
//                        gosub (i), (cDipswitch, cKnob, cRockerswitch, cRotaryswitch, cSlider, cTrackbar, cWinbutton, c4DButton, cAniButton, cColorPicker, cUserButton) ;
                        addressInternalWidget(ImageTouched, 0) ;
//                        i := xobj2iiobj[ImageTouched] ;                            // address object type and hash from ram index
//                        GObjectIdx := i & 0xff ;
//                        GObjectType := (i>>8) ;                                   // extract object type
                        if (GObjectType <= tiToggleInput) 
                            i := 0 ;
                        else if (GObjectType <= tiRotaryInput) 
                            i := 1 ;
                        else if (GObjectType <= tiSwitchB) 
                            i := 2 ;
                        else 
                            i := 3 ;
                        endif
//to(COM0) ; print(i, "\r\n") ;  

                        gosub (i), (ciButton, ciDial, ciSwitch, ciSlider) ;


//            ImageTouched := widget_Touched(wp, ALL) ;
            endif
        endif
 //       if ((n != -1) && (oldn == -1)) oldn := n ;    // save what we touched in case we move off it

        sys_EventsResume() ;
    forever

ciSwitch:
cDipswitch:

cKnob:
ciDial:

cRockerswitch:

cRotaryswitch:

cSlider:
cTrackbar:
ciSlider:

ciButton:

c4DButton:
cUserButton:
cWinbutton:
    pInputIndex := oObjects[GObjectType]  + *(CurInputData+Ofs_IPD_OBJVIDX) ;
    i := img_GetWord(hndl, *(pInputIndex), IMAGE_INDEX) ; // current state
CommonButtons:
    if (*(CurInputData+Ofs_IPD_P1))                                 // momentary, reports 0, but should report 1
        if (TouchStatus == TOUCH_RELEASED)
            i &= 0xfffe ;
            TouchState == Ofs_IPD_DOWN ;
        else
            i |= 1 ;
            TouchState == Ofs_IPD_RELEASE ;
        endif
    else if (*(CurInputData+Ofs_IPD_P2) == -1)                      // Toggle, reports 0+2, but should report 0+1
        if (TouchStatus == TOUCH_RELEASED)                     // only truly change on release
            if ((i & 3) == 3)
                i &= 0xfffc ;
            else
                i++ ;
            endif
        else
            i |= 1 ;                                      // make down regardless of current state
        endif
    else                        // group action, up all other buttons on touch press, reports 0 for button down
        if (TouchStatus == TOUCH_PRESSED)                     // only truly change on release
            TurnOffButtons(*(CurInputData+Ofs_IPD_P2)) ;
        endif
        if (GObjectType < tiLedDigits)
            i := (i & 0xfffc) | 2 ;         // uSD button, four, grouping and blocking states
        else
            i := 1 ;                        // Internal button two states
        endif
    endif

    UpdateObjects(i) ;
endsub ;

cAniButton:

cColorPicker:

endfunc
// End P6.inc
